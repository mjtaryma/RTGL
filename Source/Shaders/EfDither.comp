// Copyright (c) 2022 Sultim Tsyrendashiev
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

struct EffectDither_PushConst
{
    float intensity;
};

#define EFFECT_PUSH_CONST_T EffectDither_PushConst
#include "EfSimple.inl"


#define DITHER_TEXTURE_SIZE_X 36
#define DITHER_TEXTURE_SIZE_Y 4

float getPattern( vec2 uv )
{
    ivec2 at = ivec2( uv.x * DITHER_TEXTURE_SIZE_X, uv.y * DITHER_TEXTURE_SIZE_Y );

    // pattern texture is 36x4
    at = ivec2( at.x % DITHER_TEXTURE_SIZE_X, at.y % DITHER_TEXTURE_SIZE_Y );

    // the pixels with x=32..36 are 1.0
    if( at.x >= 32 )
    {
        return 1.0;
    }

    // the pixels with x=0..31 are encoded in bit mask; each line is y
    const uint pattern[] = {
        0x8aaaeff,
        0x4555d,
        0x2aaabff,
        0x15557,
    };

    // test bit at.x, at.y
    return ( pattern[ at.y ] & ( 1 << ( 31 - at.x ) ) ) != 0 ? 1.0 : 0.0;
}


// from https://github.com/jmickle66666666/PSX-Dither-Shader/blob/master/PSX%20Dither.shader (Created by https://github.com/jmickle66666666)
// and https://www.shadertoy.com/view/tlc3DM (Created by BitOfGold in 2019-12-16)


// ported to shaderToy by LÃ¡szlÃ³ Matuska / @BitOfGold
// from here: https://github.com/jmickle66666666/PSX-Dither-Shader/blob/master/PSX%20Dither.shader
// uses Shadertoy's 8x8 bayer dithering pattern instead of the original pattern

// Number of colors. 32 (5 bits) per channel
const vec3 _Colors = vec3(32.0);

float channelError(float col, float colMin, float colMax)
{
    float range = abs(colMin - colMax);
    float aRange = abs(col - colMin);
    return aRange /range;
}

float ditheredChannel(float error, vec2 ditherBlockUV, float ditherSteps)
{
    error = floor(error * ditherSteps) / ditherSteps;
    vec2 ditherUV = vec2(error + ditherBlockUV.x, ditherBlockUV.y);
    return getPattern(ditherUV);
}

/// YUV/RGB color space calculations

vec3 RGBtoYUV(vec3 rgb) {
    vec3 yuv;
    yuv.r = rgb.r * 0.2126 + 0.7152 * rgb.g + 0.0722 * rgb.b;
    yuv.g = (rgb.b - yuv.r) / 1.8556;
    yuv.b = (rgb.r - yuv.r) / 1.5748;

    // Adjust to work on GPU
    yuv.gb += 0.5;

    return yuv;
}

vec3 YUVtoRGB(vec3 yuv) {
    yuv.gb -= 0.5;
    return vec3(
        yuv.r * 1.0 + yuv.g * 0.0 + yuv.b * 1.5748,
        yuv.r * 1.0 + yuv.g * -0.187324 + yuv.b * -0.468124,
        yuv.r * 1.0 + yuv.g * 1.8556 + yuv.b * 0.0);
}

vec3 ditherColor(vec3 col, vec2 uv, ivec2 windowsize) {
    vec3 yuv = RGBtoYUV(col);

    vec3 col1 = floor(yuv * _Colors) / _Colors;
    vec3 col2 = ceil(yuv * _Colors) / _Colors;
    
    // Calculate dither texture UV based on the input texture
    float ditherSize = DITHER_TEXTURE_SIZE_Y;
    float ditherSteps = DITHER_TEXTURE_SIZE_X / ditherSize;
   
    vec2 ditherBlockUV;
    ditherBlockUV.x = mod(uv.x, (ditherSize / windowsize.x));
    ditherBlockUV.x /= (ditherSize / windowsize.x);
    ditherBlockUV.y = mod(uv.y, (ditherSize / windowsize.y));
    ditherBlockUV.y /= (ditherSize / windowsize.y);
    ditherBlockUV.x /= ditherSteps;

    yuv.x = mix(col1.x, col2.x, ditheredChannel(channelError(yuv.x, col1.x, col2.x), ditherBlockUV, ditherSteps));
    yuv.y = mix(col1.y, col2.y, ditheredChannel(channelError(yuv.y, col1.y, col2.y), ditherBlockUV, ditherSteps));
    yuv.z = mix(col1.z, col2.z, ditheredChannel(channelError(yuv.z, col1.z, col2.z), ditherBlockUV, ditherSteps));
    
    return(YUVtoRGB(yuv));
}


void main()
{
    const ivec2 pix = ivec2( gl_GlobalInvocationID.x, gl_GlobalInvocationID.y );
    if( !effect_isPixValid( pix ) )
    {
        return;
    }

    vec3 original = effect_loadFromSource( pix );

    vec3 c = mix( original,
                  ditherColor( original, effect_getFramebufUV( pix ), effect_getFramebufSize() ),
                  getProgress() * push.custom.intensity );
    effect_storeToTarget( c, pix );
}
